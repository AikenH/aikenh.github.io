<!doctype html>
<html lang="cn"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Python Notebook 01 - AikenH Blogs</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Aiken Hong"><meta name="msapplication-TileImage" content="/img/pokemon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Aiken Hong"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="@Aiken 2021  you know what 主要参考文献：《Python Cookbook》 &amp;amp;&amp;amp; 《Fluent Python》 数据模型（Python结构的通用范式）（Magic method）dunder method：Python特有的双下划线方法，这些方法能够支持Python进行特殊的调用，实现通用方法在新定义的数据结构上的使用，比如最典型的:  __len__"><meta property="og:type" content="blog"><meta property="og:title" content="Python Notebook 01"><meta property="og:url" content="http://aikenh.cn/cn/Python/"><meta property="og:site_name" content="AikenH Blogs"><meta property="og:description" content="@Aiken 2021  you know what 主要参考文献：《Python Cookbook》 &amp;amp;&amp;amp; 《Fluent Python》 数据模型（Python结构的通用范式）（Magic method）dunder method：Python特有的双下划线方法，这些方法能够支持Python进行特殊的调用，实现通用方法在新定义的数据结构上的使用，比如最典型的:  __len__"><meta property="og:locale" content="cn"><meta property="og:image" content="http://aikenh.cn/img/header_img/lml_bg21.jpg"><meta property="article:published_time" content="2021-10-27T06:19:13.000Z"><meta property="article:modified_time" content="2023-10-30T09:27:38.575Z"><meta property="article:author" content="AikenH"><meta property="article:tag" content="Python"><meta property="article:tag" content="Langs"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://aikenh.cn/img/header_img/lml_bg21.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://aikenh.cn/cn/Python/"},"headline":"Python Notebook 01","image":["http://aikenh.cn/img/header_img/lml_bg21.jpg"],"datePublished":"2021-10-27T06:19:13.000Z","dateModified":"2023-10-30T09:27:38.575Z","author":{"@type":"Person","name":"AikenH"},"publisher":{"@type":"Organization","name":"AikenH Blogs","logo":{"@type":"ImageObject","url":{"text":"Aiken's Blog"}}},"description":"@Aiken 2021  you know what 主要参考文献：《Python Cookbook》 &amp;&amp; 《Fluent Python》 数据模型（Python结构的通用范式）（Magic method）dunder method：Python特有的双下划线方法，这些方法能够支持Python进行特殊的调用，实现通用方法在新定义的数据结构上的使用，比如最典型的:  __len__"}</script><link rel="canonical" href="http://aikenh.cn/cn/Python/"><link rel="icon" href="/img/pokemon.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css" title="default"><link rel="alternate stylesheet" href="/css/cyberpunk.css" title="cyberpunk"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.2.0"><link rel="alternate" href="/atom.xml" title="AikenH Blogs" type="application/atom+xml">
</head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Aiken&#039;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/AikenH"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item night" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-lightbulb" id="night-icon"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/header_img/lml_bg21.jpg" alt="Python Notebook 01"></span></div><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>Python Notebook 01</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="2021-10-27T06:19:13.000Z" title="2021-10-27T06:19:13.000Z">2021-10-27</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-10-30T09:27:38.575Z" title="2023/10/30 17:27:38">2023-10-30</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a></span><span class="level-item">an hour read (About 6721 words)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>&nbsp;visits</span></div></div><div class="content"><p>@Aiken 2021  you know what</p>
<p>主要参考文献：《Python Cookbook》 &amp;&amp; 《Fluent Python》</p>
<h1 id="数据模型（Python结构的通用范式）"><a href="#数据模型（Python结构的通用范式）" class="headerlink" title="数据模型（Python结构的通用范式）"></a>数据模型（Python结构的通用范式）</h1><p>（Magic method）dunder method：Python特有的双下划线方法，这些方法能够支持Python进行特殊的调用，实现通用方法在新定义的数据结构上的使用，比如最典型的:</p>
<ul>
<li><code>__len__()</code>后可以支持<code>len()</code>，获得结构的长度</li>
<li><p><code>__getitem__()</code>后可以支持<code>data[index]</code>来获取相应的元素，切片，等等数组的操作；</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 也可以支持类似如下的一些操作</span><br><span class="hljs-comment"># 从数据结构中随机选出一个items</span><br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> choice<br>choice(datas)<br><span class="hljs-comment"># 也可以支持迭代方法和反迭代方法</span><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> datas:<br>    ...<br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> <span class="hljs-built_in">reversed</span>(datas):<br>    ...<br><span class="hljs-comment"># 也可以支持sort函数</span><br><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>到这里也就说明了，只要我们在数据结构（class）中定义了相应的dunder method，该class就能支持相应的一系列操作，getitems就可以类比为列表，相应的操作都能够在python解释器下自动的赋予支持。</p>
<p>还有一些好用但不常用的方法：</p>
<ul>
<li><code>__contain__</code>实现的是<code>in</code> ，当没有实现contain的方法的时候会按照顺序在list中进行搜索</li>
<li><code>__abs__</code></li>
<li><code>__repr__</code>实现的是输出的format设置，也就是print的时候的输出形式</li>
<li><code>__eq__</code> 实现的是  == 命令，同时in调用的是<strong>eq</strong></li>
</ul>
<p>下面附上一张特殊方法表：<br><span id="more"></span></p>
<h3 id="基本命名规范"><a href="#基本命名规范" class="headerlink" title="基本命名规范"></a>基本命名规范</h3><p>相关的文件和函数等命名规则。</p>
<p><a href="Python%20Notebook%20ad3f0aafe5a54942bdcc3694a9a88976/%E5%91%BD%E5%90%8D%E6%A0%B7%E4%BE%8B%E8%A1%A8%2039d2a928f8bf4624afc2e0006ffcd528.csv">命名样例表</a></p>
<h1 id="变量赋值传递时的引用和拷贝"><a href="#变量赋值传递时的引用和拷贝" class="headerlink" title="变量赋值传递时的引用和拷贝"></a>变量赋值传递时的引用和拷贝</h1><p>Python 变量的传递类型：（赋值过程）<br><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/python-variable-references-and-copies.html">https://www.runoob.com/w3cnote/python-variable-references-and-copies.html</a></p>
<p>Python 赋值过程中不明确区分拷贝和引用，一般对静态变量的传递为拷贝，对动态变量的传递为引用。（注，对静态变量首次传递时也是引用，当需要修改静态变量时，因为静态变量不能改变，所以需要生成一个新的空间存储数据）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">•  字符串，数值，元组 均为静态变量<br>• 列表，字典为动态变量。<br></code></pre></td></tr></table></figure>
<p>可以用id（）查看指向的地址</p>
<p>在修改列表值之类的时候要注意这一点，不然可能会影响到源列表，可能要使用深拷贝的方法，<br>copy.deepcopy()</p>
<p>python 定义方法时候指定<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xxpythonxx/p/12198876.html">参数，返回值和变量的类型</a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">a:<span class="hljs-built_in">int</span>, b:<span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-built_in">print</span>(a, b)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test(<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h1 id="类与函数"><a href="#类与函数" class="headerlink" title="类与函数"></a>类与函数</h1><p>args，kwargs的用法和解包，主要将字典作为参数整体传入的这种方法值得学习</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">可以用*，**定义和解包<br><br></code></pre></td></tr></table></figure>
<p>id()可以获取变量的地址，type（）查看数据类型，isinstance判断类型</p>
<p>locals().keys() 获得当前已经声明的变量列表</p>
<p>sys.argv[0] 可获取当前工作区的地址</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><h2 id="单下划线"><a href="#单下划线" class="headerlink" title="单下划线"></a>单下划线</h2><p>定义的函数，属性，或者方法 这表明这个member是受保护的：</p>
<ul>
<li>是用来指定私有变量和方法的方式（只是一种约定习惯）,不希望被下游的程序员直接访问的函数。</li>
<li>如果使用<code>from a_module import</code>导入时，这部分变量和函数不会被导入</li>
<li>但是如果使用 <code>import a_module</code>这样导入模块，仍然可以用<code>a_module._pythonPoint</code>这样的形式访问到这样的对象。</li>
</ul>
<h2 id="Bool-and-or-not"><a href="#Bool-and-or-not" class="headerlink" title="Bool and or not"></a>Bool and or not</h2><p>基本的就不用daaaaaaaaaaaaaaaaaaa说了，主要是一些特殊的用法举例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># not 会先于 and 执行</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> flag1 <span class="hljs-keyword">and</span> flag2 == <span class="hljs-literal">True</span><br><br></code></pre></td></tr></table></figure>
<p>用逻辑运算符做参数选择</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">judge = index == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> num1 <span class="hljs-keyword">or</span> num2<br><br></code></pre></td></tr></table></figure>
<h2 id="Argparse"><a href="#Argparse" class="headerlink" title="Argparse"></a>Argparse</h2><p>基本的用法：参考universal framework即可，主要是bool类型无法通过命令行传入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用store_true属性，就可以执行默认的True or False</span><br>parser.add_argument(<span class="hljs-string">&quot;--bool_chose&quot;</span>,default=<span class="hljs-literal">False</span> ,action=<span class="hljs-string">&#x27;store_true&#x27;</span>,<span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;a switch of bool variable&#x27;</span>)<br><span class="hljs-comment"># 👇选择上与原本完全是相反的</span><br>parser.add_argument(<span class="hljs-string">&quot;--bool_chose&quot;</span>,default=<span class="hljs-literal">True</span> ,action=<span class="hljs-string">&#x27;store_true&#x27;</span>,<span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;a switch of bool variable&#x27;</span>)<br><br></code></pre></td></tr></table></figure>
<h2 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h2><p>使用<strong>sample</strong>不重复的选取字典或者列表中的指定项</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>choose = random.sample(<span class="hljs-built_in">list</span>,<span class="hljs-number">2</span>)<br><br></code></pre></td></tr></table></figure>
<p>使用<strong>choice</strong>进行可重复的选取</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">c_r = np.arange(<span class="hljs-number">20</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    c_i = random.choice(c_r)<br>    <span class="hljs-built_in">print</span>(c_i)<br><br></code></pre></td></tr></table></figure>
<p><strong>打乱列表排序</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">A = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br><span class="hljs-comment"># 得到index的列表</span><br>B = np.arange(<span class="hljs-built_in">len</span>(A))<br><span class="hljs-comment"># 对该列表进行打乱，通过打乱的列表进行索引</span><br>random.shuffle(B)<br><span class="hljs-built_in">print</span>(B)<br><br></code></pre></td></tr></table></figure>
<h1 id="Logging-System"><a href="#Logging-System" class="headerlink" title="Logging System"></a>Logging System</h1><p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.9/howto/logging.html#logging-basic-tutorial">日志 HOWTO — Python 3.9.4 文档</a>；<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.9/howto/logging-cookbook.html#logging-cookbook">日志操作手册 — Python 3.9.4 文档</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yyds/p/6901864.html">Python logging模块</a>；<a target="_blank" rel="noopener" href="https://blog.csdn.net/hunt_ing/article/details/82080923">logging模块的简单使用</a></p>
<h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><p>从一个非常简单的例子开始，默认的命令行输出等级是warning</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br>logging.debug(<span class="hljs-string">&#x27;this message should only show up in log file&#x27;</span>)<br>logging.info(<span class="hljs-string">&#x27;so do this one &#x27;</span>)<br>logging.warning(<span class="hljs-string">&#x27;this one will also show up in the console&#x27;</span>)<br>logging.error(<span class="hljs-string">&#x27;And non-ASCII stuff, too, like resund and Malm&#x27;</span>)<br><br></code></pre></td></tr></table></figure>
<p>假如我们设置log文件的存储以及输出的格式（包括算法运行的时间）</p>
<ul>
<li>但是注意这个config是一次性设置，只有第一次设置是有效的</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.basicConfig(<span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s %(levelname)s %(message)s &#x27;</span>, datefmt=<span class="hljs-string">&#x27;%Y-%m-%d %I:%M:%S %p&#x27;</span>,   filename=<span class="hljs-string">&quot;exampleFile.log&quot;</span>,level=logging.DEBUG)<br><span class="hljs-comment"># 这里设置了文件的输出名称和输出的格式，以及相应的记录到文件中的等级</span><br><br></code></pre></td></tr></table></figure>
<p>也可以从命令行设置日志等级,可以获取当前的等级</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">--<span class="hljs-built_in">log</span> = INFO<br><span class="hljs-comment"># getattr 这个方法目前好像还有点问题，</span><br><br></code></pre></td></tr></table></figure>
<h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><p>通过4个module的组合来实现record log的功能，通过Logger载入多个Handler，可以通过不同的标准和方式在多个File以及控制台输出不同Level的东西，这就是主要的功能。</p>
<p><a href="Python%20Notebook%20ad3f0aafe5a54942bdcc3694a9a88976/Untitled%20Database%209ccf70326eeb44a0b8e876f6a26ea12c.csv">Untitled</a></p>
<p>具体的实现样例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-comment"># create logger to record log messages</span><br>logger = logging.getLogger(<span class="hljs-string">&#x27;textlogger&#x27;</span>)<br><span class="hljs-comment"># 避免等级c</span><br>logger.propagate = <span class="hljs-number">0</span><br>logger.setLevel(logging.DEBUG)<br><span class="hljs-comment"># create file handler which logs even debug messages</span><br>fh = logging.FileHandler(<span class="hljs-string">&#x27;exampleFile.log&#x27;</span>)<br>fh.setLevel(logging.WARNING)<br><span class="hljs-comment"># creatr console handler...</span><br>ch = logging.StreamHandler()<br>ch.setLevel(logging.DEBUG)<br><span class="hljs-comment"># create output format  for all the handler</span><br>formatter = logging.Formatter(<span class="hljs-string">&#x27;%(asctime)s %(levelname)s %(message)s &#x27;</span>,<br>                    datefmt=<span class="hljs-string">&#x27;%Y-%m-%d %I:%M:%S %p&#x27;</span>)<br>ch.setFormatter(formatter)<br>fh.setFormatter(formatter)<br><span class="hljs-comment"># add handler to logger</span><br>logger.addHandler(ch)<br>logger.addHandler(fh)<br><span class="hljs-comment"># record logs</span><br>logger.debug(<span class="hljs-string">&#x27;this message should only show up in log file &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;test is&#x27;</span>))<br>logger.info(<span class="hljs-string">&#x27;so do this one &#x27;</span>)<br>logger.warning(<span class="hljs-string">&#x27;this one will also show up in the console&#x27;</span>)<br>logger.error(<span class="hljs-string">&#x27;show up twice&#x27;</span>)<br><br></code></pre></td></tr></table></figure>
<p>但是这种格式的时候怎么实现跨文件传输呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">再同个文件中我们只需要进行getlogger使用同一个名字即可获得同一个logger，但是跨文件的话可能还是需要传递logger把。<br><br></code></pre></td></tr></table></figure>
<p>我认为应该传递该<code>logger</code>,然后通过该Logger进行统一的输出，遇到不同的输出要求的时候，我们可以对handler进行不一样的处理从而能够得到多样化的logger输出</p>
<h2 id="Logger与装饰器的组合使用"><a href="#Logger与装饰器的组合使用" class="headerlink" title="Logger与装饰器的组合使用"></a>Logger与装饰器的组合使用</h2><p>参见后续的装饰器解读模块</p>
<h1 id="FIles-System"><a href="#FIles-System" class="headerlink" title="FIles System"></a>FIles System</h1><h2 id="Import-manage"><a href="#Import-manage" class="headerlink" title="Import manage"></a>Import manage</h2><h3 id="init-py-文件的作用"><a href="#init-py-文件的作用" class="headerlink" title="init.py 文件的作用"></a><strong>init</strong>.py 文件的作用</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/BlueSkyyj/p/9415087.html"><strong>init</strong>.py 文件使用</a></p>
<p>其实主要就是控制着包的导入功能，使用<code>__all__</code>来对应<code>from package import *</code>的功能，我们可以在<code>init</code>中批量的导入我们需要的模块，这样我们就不在需要一个个的进行导入了，基于这种特性，我们也可以编写一个manage fuction，通过config来进行选择性的导入。</p>
<ul>
<li>主要的左右是python中package的标识，不能删除</li>
<li>定义<code>__all__</code>用来进行模糊导入</li>
<li>编写python代码，会在import package的时候同时import，但是推荐在包中创建另外的模块来写，尽量保证该文件简单</li>
</ul>
<h2 id="Path-Manage"><a href="#Path-Manage" class="headerlink" title="Path Manage"></a>Path Manage</h2><h3 id="路径切分"><a href="#路径切分" class="headerlink" title="路径切分"></a>路径切分</h3><p>将路径切分成地址和文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>p,f = os.path.split(origin)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;path == &quot;</span>,p)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;file == &quot;</span>,f)<br><br></code></pre></td></tr></table></figure>
<p>切分出文件的盘符和文件名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">dev,left = os.path.splitdrive(origin)<br><br></code></pre></td></tr></table></figure>
<p>切分出文件和拓展名</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">f,ext = os.path.splittext(origin)<br><br></code></pre></td></tr></table></figure>
<h2 id="文件遍历"><a href="#文件遍历" class="headerlink" title="文件遍历"></a>文件遍历</h2><h3 id="os-walk"><a href="#os-walk" class="headerlink" title="os.walk()"></a>os.walk()</h3><p>简单好用的<strong>目录遍历器</strong>用于在目录树中游走输出目录中的文件名，向上或者向下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">os.walk(top,topdown,onerror,followlinks)<br><br></code></pre></td></tr></table></figure>
<ul>
<li>top：遍历的目录地址</li>
<li>（option）topdown：True的话优先遍历top目录，否则会优先遍历子目录</li>
<li>（option）onerror：当需要异常的时候，会调用</li>
<li>（option）followlinks：是否要跳转到快捷方式（或者软连接遍历）</li>
</ul>
<p><strong>RETURN：（root，dirs，files）</strong></p>
<ol>
<li>root：根目录</li>
<li>dirs：文件夹中所有目录的名字（子文件夹）</li>
<li>files：目录中所有文件的名字</li>
</ol>
<p><strong>层序遍历每次是该层的所有文件和目录的名字</strong></p>
<h3 id="Glob-glob"><a href="#Glob-glob" class="headerlink" title="Glob.glob()"></a>Glob.glob()</h3><p>文件遍历方法</p>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h1 id="Data-Structural"><a href="#Data-Structural" class="headerlink" title="Data Structural"></a>Data Structural</h1><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位运算判断奇偶一致性</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># T：奇偶性不一致 F：奇偶性一致</span><br>(a ^ b) &amp; 1<br></code></pre></td></tr></table></figure>
<h2 id="二进制操作"><a href="#二进制操作" class="headerlink" title="二进制操作"></a>二进制操作</h2><p>与或非就不用多说，主要是介绍一个module bitarray</p>
<h2 id="序列构成的数组"><a href="#序列构成的数组" class="headerlink" title="序列构成的数组"></a>序列构成的数组</h2><p>这一部分主要有几个重点：<strong>列表推导式的使用</strong>、<strong>元组特性和使用</strong></p>
<h3 id="列表推导式的使用"><a href="#列表推导式的使用" class="headerlink" title="列表推导式的使用"></a>列表推导式的使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将字符串变成Unicode码位</span><br>symbols = <span class="hljs-string">&#x27;sdac@#&#x27;</span><br>codes = [<span class="hljs-built_in">ord</span>(symbol) <span class="hljs-keyword">for</span> symbol <span class="hljs-keyword">in</span> symbols <span class="hljs-keyword">if</span> <span class="hljs-built_in">ord</span>(symbol) &gt;<span class="hljs-number">127</span>]<br><span class="hljs-comment"># 与map和filter的比较</span><br>lists(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> c:c&gt;<span class="hljs-number">127</span>, <span class="hljs-built_in">map</span>(<span class="hljs-built_in">ord</span>,symbols)))<br><br></code></pre></td></tr></table></figure>
<p>可以看出列表推导式的表达更为简洁易懂，而且实际上运行的效率也不低</p>
<h3 id="使用列表推导式生成笛卡尔积"><a href="#使用列表推导式生成笛卡尔积" class="headerlink" title="使用列表推导式生成笛卡尔积"></a>使用列表推导式生成笛卡尔积</h3><p>举例：每个size有不同的颜色</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">colors = [<span class="hljs-string">&#x27;black&#x27;</span>,<span class="hljs-string">&#x27;blue&#x27;</span>,<span class="hljs-string">&#x27;red&#x27;</span>]<br>sizes = [<span class="hljs-string">&#x27;S&#x27;</span>,<span class="hljs-string">&#x27;M&#x27;</span>,<span class="hljs-string">&#x27;L&#x27;</span>]<br><span class="hljs-comment"># 先按颜色循环再按size循环，内外层循环的关系</span><br>tshirts = [(color,size) <span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> colors <span class="hljs-keyword">for</span> size <span class="hljs-keyword">in</span> sizes]<br><br></code></pre></td></tr></table></figure>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>我们可以使用列表推导来初始化元组、数组、或者其他的数据类型，但是生成器表达式符合了迭代器的协议，可以逐个的产出元素，而不是先建立一个完整的列表，能够节省内存</p>
<p><strong>语法上和列表推导差不多，只不过把方括号换成圆括号而已</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">ord</span>(symbol) <span class="hljs-keyword">for</span> symbol <span class="hljs-keyword">in</span> symbols)<br><span class="hljs-keyword">import</span> array<br>array.array(<span class="hljs-string">&#x27;I&#x27;</span>,<span class="hljs-built_in">ord</span>(symbol) <span class="hljs-keyword">for</span> symbol <span class="hljs-keyword">in</span> symbols)<br><br></code></pre></td></tr></table></figure>
<p><strong>利用生成器表达式来计算笛卡尔积</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这样可以更好的体现逐个生成的特性？但是实际上列表推导式也可以把？</span><br><span class="hljs-comment"># 但是总之是由这样的特性的，能够避免额外的内存占用</span><br><span class="hljs-keyword">for</span> tshirt <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;%s %s&#x27;</span> %(c,s) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> colors <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> sizes):<br>    <span class="hljs-built_in">print</span>(tshirt)<br><br></code></pre></td></tr></table></figure>
<h3 id="元组不仅是不可变的列表"><a href="#元组不仅是不可变的列表" class="headerlink" title="元组不仅是不可变的列表"></a>元组不仅是不可变的列表</h3><h2 id="列表的基本操作"><a href="#列表的基本操作" class="headerlink" title="列表的基本操作"></a>列表的基本操作</h2><h3 id="列表的条件加和"><a href="#列表的条件加和" class="headerlink" title="列表的条件加和"></a>列表的条件加和</h3><p>有不少类似和条件语句相关的操作，列举一些基本实例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># np.random.randint?</span><br>A = np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br>B = np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;origin A　is &#123;&#125; \n And B is &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(A,B))<br><span class="hljs-comment"># style 1 相当于转换成一个ToF的list，然后对这样的list直接进行sum</span><br>same = (A == B).<span class="hljs-built_in">sum</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\nthe num of same element in same posi is&#x27;</span>, same)<br><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&#x27;&#x27;&#x27;列表的+=，也就是简单拼接操作&#x27;&#x27;&#x27;</span><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]+[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><br></code></pre></td></tr></table></figure>
<h3 id="列表的数乘"><a href="#列表的数乘" class="headerlink" title="列表的数乘"></a>列表的数乘</h3><p>列表的数乘是对列表的项数进行一个重复性的扩充，但是注意这种重复不能针对那种特殊类型（也就是赋值会直接基于地址的：引用？）<br>所以这是对于<strong>项数的操作</strong>而不是对列表中数值的直接操作，参考变量赋值的部分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">value = <span class="hljs-number">5</span><br>unlist = [value]<br>outlist = unlist * <span class="hljs-number">5</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;the output is like that : &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(outlist))<br><br></code></pre></td></tr></table></figure>
<h3 id="range函数常用操作"><a href="#range函数常用操作" class="headerlink" title="range函数常用操作"></a>range函数常用操作</h3><ul>
<li><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.7/library/stdtypes.html?highlight=range#range">https://docs.python.org/zh-cn/3.7/library/stdtypes.html?highlight=range#range</a></li>
<li>range生成的并不是列表，而是一个range组而已</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">reallist = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">20</span>))<br><span class="hljs-comment"># range的步长设置</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>,<span class="hljs-number">20</span>,<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(i)<br><br></code></pre></td></tr></table></figure>
<h2 id="Universal-Method"><a href="#Universal-Method" class="headerlink" title="Universal Method"></a>Universal Method</h2><h3 id="Sort（）对列表进行排序"><a href="#Sort（）对列表进行排序" class="headerlink" title="Sort（）对列表进行排序"></a>Sort（）对列表进行排序</h3><p>sort用于对源列表进行排序，如果指定参数，则使用指定的比较函数<br>参考资料：<a target="_blank" rel="noopener" href="https://www.runoob.com/python/att-list-sort.html">https://www.runoob.com/python/att-list-sort.html</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 纯数字的情况就按基本方式进行排列</span><br>list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">23</span>,<span class="hljs-number">4</span>]<br>list1.sort()<br>list1<br><br><span class="hljs-comment"># 类似的string就按找字母表进行逐项排序吧，我是这样理解的</span><br><br></code></pre></td></tr></table></figure>
<h2 id="队列queue-amp-deque"><a href="#队列queue-amp-deque" class="headerlink" title="队列queue &amp; deque"></a>队列queue &amp; deque</h2><h2 id="SET集合"><a href="#SET集合" class="headerlink" title="SET集合"></a>SET集合</h2><p><a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python3-set.html">https://www.runoob.com/python3/python3-set.html</a></p>
<p>{}可以定义字典，也可以用于创建集合<br>但是空的集合只能用set()定义（因为{}定义的是空字典）<br>基本的method：</p>
<ol>
<li>add、remove、discard（也是移除，但是假如元素不存在的话也不会报错）</li>
<li>len，clear</li>
</ol>
<p>主要是可以利用其中不会重复的元素的特性来进行特殊的操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">basker = &#123;<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;organge&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;pear&#x27;</span>&#125;<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;basker:&#x27;</span>, basker)<br><span class="hljs-string">&#x27;orange&#x27;</span> <span class="hljs-keyword">in</span> basker<br><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a = <span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;go straight forward&#x27;</span>)<br><span class="hljs-comment"># 可以在集合中做交并等等集合的操作</span><br></code></pre></td></tr></table></figure>
<h3 id="利用set进行去重"><a href="#利用set进行去重" class="headerlink" title="利用set进行去重"></a>利用set进行去重</h3><p>如何利用set对unhashable的data structure进行去重，这里采取的方式是使用tuple对数组进行变换；</p>
<p>实际上unhashable的原因在于对象是可变对象：比如np.array，所以我们将其转换为不可变的tuple之后就可以进行hash的计算从而进行去重了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 二维数组为例</span><br>array1 = np.random.rand(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>array1_t = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">tuple</span>,array1))<br>resume = np.array(array1_t)<br><span class="hljs-comment"># 进行转换的时候注意不要进行过度的拆分，上述的方法只适用于二维数组的情况，</span><br>text = [<span class="hljs-string">&#x27;abcsd&#x27;</span>,<span class="hljs-string">&#x27;dsdc&#x27;</span>,<span class="hljs-string">&#x27;cdsda&#x27;</span>]<br>text = <span class="hljs-built_in">tuple</span>(text)<br><span class="hljs-comment"># 即可，不然可能会将其中的文本全部拆分出来</span><br><span class="hljs-comment"># 后续补充一下map的其他用法。[func,iterator?]</span><br></code></pre></td></tr></table></figure>
<h2 id="Dict，Hashmap"><a href="#Dict，Hashmap" class="headerlink" title="Dict，Hashmap"></a>Dict，Hashmap</h2><p>实际上python中的字典就是hashmap的具体实现，是一个无序的结构</p>
<h3 id="判断字典中的key是否存在的方法"><a href="#判断字典中的key是否存在的方法" class="headerlink" title="判断字典中的key是否存在的方法"></a>判断字典中的key是否存在的方法</h3><p><strong>首先如果我们调用的key不存在的话</strong>： <code>keyerror</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;key1&#x27;</span> <span class="hljs-keyword">in</span> dict1<br>false<br><br></code></pre></td></tr></table></figure>
<p>或者使用get方法，能给不存在的key赋予默认的value,在这个时候出现的则是<code>nameerror</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>d.get(<span class="hljs-string">&#x27;key1&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>d.get(<span class="hljs-string">&#x27;key1&#x27;</span>, -<span class="hljs-number">1</span>)<br>-<span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure>
<h3 id="字典中的常用方法"><a href="#字典中的常用方法" class="headerlink" title="字典中的常用方法"></a>字典中的常用方法</h3><p>…</p>
<h3 id="collections-defaultdict-指定dict中未定义key的value"><a href="#collections-defaultdict-指定dict中未定义key的value" class="headerlink" title="collections.defaultdict 指定dict中未定义key的value"></a>collections.defaultdict 指定dict中未定义key的value</h3><ul>
<li>通过指定的默认值，在一些使用场景下可以对dict进行简化的定义</li>
<li>同时也能针对一些特殊的情况，比如说未见数据的情况，进行定义</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 指定list类型用于未定义类别的填充</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br>dict1 = &#123;&#125;<br>dict2 = defaultdict(<span class="hljs-built_in">list</span>)<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(dict1[<span class="hljs-string">&#x27;a&#x27;</span>])<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;dict1 print key error&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;dict2 is like &#x27;</span>, dict2[<span class="hljs-string">&#x27;a&#x27;</span>])<br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">dict1 print key error<br>dict2 is like  []<br><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用法2，避免keyerror更容易对其进行赋值</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br>bags = [<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;orange&#x27;</span>, <span class="hljs-string">&#x27;cherry&#x27;</span>, <span class="hljs-string">&#x27;apple&#x27;</span>,<span class="hljs-string">&#x27;apple&#x27;</span>, <span class="hljs-string">&#x27;cherry&#x27;</span>, <span class="hljs-string">&#x27;blueberry&#x27;</span>]<br>count = defaultdict(<span class="hljs-built_in">int</span>)<br><span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> bags:<br>    count[fruit] += <span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;the count output is like \n&#x27;</span>, count)<br><span class="hljs-comment"># print(locals().keys())</span><br><br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">the count output is like<br> defaultdict(&lt;class &#x27;int&#x27;&gt;, &#123;&#x27;apple&#x27;: 3, &#x27;orange&#x27;: 1, &#x27;cherry&#x27;: 2, &#x27;blueberry&#x27;: 1&#125;)<br><br></code></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用法3：可以自定义函数作为初始化的函数参数</span><br><span class="hljs-comment"># 基于这样的方法我们可以定义各种各样的默认值</span><br><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">defaultvalue</span>(<span class="hljs-params">value=<span class="hljs-number">2</span></span>): <span class="hljs-keyword">return</span> value<br>dict3 = defaultdict(defaultvalue)<br>dict3[<span class="hljs-string">&#x27;hello&#x27;</span>]<br><br></code></pre></td></tr></table></figure>
<h2 id="Vars（）"><a href="#Vars（）" class="headerlink" title="Vars（）"></a>Vars（）</h2><p><strong>vars()</strong> 函数返回对象object的属性和属性值的字典对象。</p>
<h2 id="Python中的数字日期时间计算"><a href="#Python中的数字日期时间计算" class="headerlink" title="Python中的数字日期时间计算"></a>Python中的数字日期时间计算</h2><p>@Aiken 2020</p>
<p>@Source：《Python Cookbook》 Chapter3 数字日期和时间</p>
<p>主要针对Python中的数字数字运算的运算做一个笔记</p>
<h3 id="获取本机时间的几种方法"><a href="#获取本机时间的几种方法" class="headerlink" title="获取本机时间的几种方法"></a>获取本机时间的几种方法</h3><p>主要为了<strong>方便格式化时间</strong>输出，我们需要将机器时间转换成指定的年月日之类的。<br>分别来自于time 和 datatime，这两种方式的时间复杂度好像实际上并没有太大的差别，姑且用着把暂时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_time</span>(<span class="hljs-params"><span class="hljs-built_in">type</span>=<span class="hljs-number">1</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span> == <span class="hljs-number">0</span>: now = time.strftime(<span class="hljs-string">&#x27;%m/%d:%H:%M&#x27;</span>)<br>    <span class="hljs-keyword">else</span>: now = datetime.now().strftime(<span class="hljs-string">&#x27;%m/%d:%H:%M&#x27;</span>)<br>    <span class="hljs-keyword">return</span> now<br>get_time(<span class="hljs-number">0</span>)<br><br></code></pre></td></tr></table></figure>
<h3 id="精确数字运算"><a href="#精确数字运算" class="headerlink" title="精确数字运算"></a>精确数字运算</h3><p>我们知道python中的计算不是绝对精准的， 浮点的精度是有限的，但是当我们需要进行金融领域或者数学领域的一些高精度要求的计算，可以为其牺牲一定的复杂度的时候👉decimal模块</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal<br>a = Decimal(<span class="hljs-string">&#x27;4.2&#x27;</span>)<br>b = Decimal(<span class="hljs-string">&#x27;2.1&#x27;</span>)<br><span class="hljs-built_in">print</span>(a + b, a+b==Decimal(<span class="hljs-string">&#x27;6.3&#x27;</span>))<br><span class="hljs-comment"># 注意数据的类型实际上也是Decimal</span><br><span class="hljs-comment"># 能控制计算的每一方面，包括数字位数和四舍五入之类的，需要创建一个本地的上下文</span><br><span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> localcontext<br><span class="hljs-comment"># 精确度控制</span><br><span class="hljs-keyword">with</span> localcontext() <span class="hljs-keyword">as</span> ctx:<br>    ctx.prec = <span class="hljs-number">3</span><br>    <span class="hljs-built_in">print</span>(a/b)<br><br></code></pre></td></tr></table></figure>
<p><strong>计算方法中的大数吃小数的情况</strong></p>
<p>(运算中的量纲差异超过17位的浮点数精度的情况)使用math.fsum()函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br>nums = [<span class="hljs-number">1.23e+18</span>，<span class="hljs-number">1</span>，-<span class="hljs-number">1.23e+18</span>]<br><span class="hljs-keyword">assert</span> <span class="hljs-built_in">sum</span>(nums) != math.fsum(nums), <span class="hljs-string">&#x27;the correct ans is fsum &#123;&#125;, error ans is sum &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(math.fsum(nums),<span class="hljs-built_in">sum</span>(nums))<br><span class="hljs-comment"># we can find it what we meet and waht we want.</span><br><br></code></pre></td></tr></table></figure>
<h3 id="数字的格式化输出"><a href="#数字的格式化输出" class="headerlink" title="数字的格式化输出"></a>数字的格式化输出</h3><p>控制输出的格式（精确度，对齐，千分位分割符）<code>format</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">1234.56789</span><br>anslist = []<br>value = <span class="hljs-built_in">format</span>(x, <span class="hljs-string">&#x27;0.2f&#x27;</span>)   <span class="hljs-comment"># 👈 两位小数</span><br>anslist.append(value)<br><br></code></pre></td></tr></table></figure>
<p><a href="Python%20Notebook%20ad3f0aafe5a54942bdcc3694a9a88976/Untitled%20Database%20400b9d461cf240e18dd2268ce561adf1.csv">Untitled</a></p>
<p><strong>进制转换：</strong></p>
<blockquote>
<p>2,8,16 -&gt; bin（） oct（） hex（）  OR format(x, ‘b’) format(x, ‘o’) format(x, ‘h’)</p>
</blockquote>
<p><strong>复数运算</strong></p>
<blockquote>
<p><code>complex(real, imag)``numpy</code>好像能处理复数<code>cmath</code>一些math无法处理的复数运算</p>
</blockquote>
<p><strong>正负无穷于NaN（非数字）</strong></p>
<blockquote>
<p>inf，-inf，nan， 可以使用float(‘inf’)创建验证 <code>math.isinf()</code></p>
</blockquote>
<p><strong>分数运算</strong></p>
<blockquote>
<p>Fractions（5，4）==5/4.numerator 分子 .denominator 分母</p>
</blockquote>
<h1 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h1><p>主要包括迭代的模块和解包的一些相关操作：</p>
<h3 id="enumerate-、items、zip"><a href="#enumerate-、items、zip" class="headerlink" title="enumerate 、items、zip"></a>enumerate 、items、zip</h3><ol>
<li><code>enumerate</code>可以将可迭代对象，除了dict，解压出来，并自带序号（多加入一个维度）。</li>
<li>字典的解包主要靠<code>items（）</code></li>
<li><p><code>zip</code>将可迭代对象作为参数，把每一项可迭代对象中取出一个值，组合成一个个元组，，然后返回。</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> a,b,c <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(A,B,C):<br>    ...<br><br></code></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h1><h2 id="Some-Rules"><a href="#Some-Rules" class="headerlink" title="Some Rules"></a>Some Rules</h2><ul>
<li><code>-&gt;</code>in python: 常常出现在python函数定义的函数名后面，为函数添加元数据，描述函数的返回类型，从而方面开发人员使用。</li>
<li><p>拓展：进行函数内的参数定义的时候也可以用冒号指定类型，以及默认值</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">isPre: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span></span>): <span class="hljs-keyword">pass</span><br><br></code></pre></td></tr></table></figure>
</li>
</ul>
<p>-</p>
<h2 id="装饰器模块"><a href="#装饰器模块" class="headerlink" title="装饰器模块"></a>装饰器模块</h2><p>装饰器在我个人的理解里面更像是一个嵌套的函数结构，编写装饰器实际上是为了给函数<strong>套壳</strong>，最根本的目的仍然是为了repeat coding，而这样的写法最直接适用的有以下的几种情况：</p>
<ul>
<li>Timing or Logging</li>
<li>当成函数指针进行函数的传递（但是这点上实际上用类传递的方式可能会更常见一点）</li>
</ul>
<h3 id="Basic-Type"><a href="#Basic-Type" class="headerlink" title="Basic Type"></a>Basic Type</h3><p>最基本的编写样例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> functional <span class="hljs-keyword">import</span> wraps<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">timethis</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;Decorator that report the execution time.</span><br><span class="hljs-string">    this Decorator can not accept parameters&#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 通过下面这个内置的装饰器来保留func的元信息 __name__ __doc___之类的</span><br><span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args,**kwargs</span>):<br>        <span class="hljs-comment"># * ** 来保证可以对func传入各种参数</span><br>        start = time.time()<br>        result = func(*args, **kwargs)<br>        end = time.time()<br>        <span class="hljs-built_in">print</span>(func.__name__, end - start)<br>        <span class="hljs-keyword">return</span> result<br>    <span class="hljs-keyword">return</span> wrapper<br><br></code></pre></td></tr></table></figure>
<h3 id="接受参数传递"><a href="#接受参数传递" class="headerlink" title="接受参数传递"></a>接受参数传递</h3><p>但是这个装饰器实际上不满足我们的需求，我们希望装饰器能<strong>接受传入的参数</strong>，这样的话，我们才能更好的进行print或者是使用logging这个模块。</p>
<p>Then we can write it like this :</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 实际上直观的理解的话，就是在外面再多嵌套一层函数，通过这个函数来对我们的decorator传递需要的参数</span><br><span class="hljs-keyword">from</span> functional <span class="hljs-keyword">import</span> wraps<br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-comment"># 实现对装饰器的参数传递，同时和</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">logged</span>(<span class="hljs-params">level, name=<span class="hljs-literal">None</span>,message=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;通过最外层接受参数并将其传递到内层的装饰器中&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorate</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-comment"># setting paramter we passing here</span><br>        logname = name <span class="hljs-keyword">if</span> name <span class="hljs-keyword">else</span> func.__moudule__<br>        log = logging.getLogger(logname)<br>        logmsg = message <span class="hljs-keyword">if</span> message <span class="hljs-keyword">else</span> func.__name__<br><br><span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args,**kwargs</span>):<br>            log.log(level,logmsg)<br>            <span class="hljs-keyword">return</span> func(*args,**kwargs)<br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorate<br><br><span class="hljs-comment"># 但是实际上我们要传递的就是一些输出结果，所以我们不需要用到这一点，只要再内部赋予logging就行了，所以这里我们设定的就是基本的level和logger_nanme</span><br><br></code></pre></td></tr></table></figure>
<h3 id="修改装饰器参数"><a href="#修改装饰器参数" class="headerlink" title="修改装饰器参数"></a>修改装饰器参数</h3><p>对上面这个装饰器模块进行简单的改进，<strong>就能使得用包装器包装的函数，能够调用附加函数来修改装饰器的参数</strong></p>
<p>（相当于赋予被装饰方法一个对装饰器的类外访问函数）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这里有个模块就比较猎奇了，以前倒是没见过</span><br><span class="hljs-keyword">from</span> functional <span class="hljs-keyword">import</span> wraps,partial<br><span class="hljs-keyword">import</span> logging<br><br><span class="hljs-comment"># utility decorator to attach a functional as an attribute of obj</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">attach_wrapper</span>(<span class="hljs-params">obj, func=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> func <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> partial(attach_wrapper, obj)<br>    <span class="hljs-built_in">setattr</span>(obj, func.__name__,func)<br>    <span class="hljs-keyword">return</span> func<br><br><span class="hljs-comment">#原有装饰器上面添加东西即可</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">logged</span>(<span class="hljs-params">level, name=<span class="hljs-literal">None</span>,message=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;通过最外层接受参数并将其传递到内层的装饰器中&#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decorate</span>(<span class="hljs-params">func</span>):<br>        <span class="hljs-comment"># setting paramter we passing here</span><br>        logname = name <span class="hljs-keyword">if</span> name <span class="hljs-keyword">else</span> func.__moudule__<br>        log = logging.getLogger(logname)<br>        logmsg = message <span class="hljs-keyword">if</span> message <span class="hljs-keyword">else</span> func.__name__<br><br><span class="hljs-meta">        @wraps(<span class="hljs-params">func</span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args,**kwargs</span>):<br>            log.log(level,logmsg)<br>            <span class="hljs-keyword">return</span> func(*args,**kwargs)<br><br>        <span class="hljs-string">&#x27;&#x27;&#x27;使用nonlocal添加属性修改的模块&#x27;&#x27;&#x27;</span><br><span class="hljs-meta">        @attach_wrapper(<span class="hljs-params">wrapper</span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_level</span>(<span class="hljs-params">newlevel</span>):<br>            <span class="hljs-keyword">nonlocal</span> level<br>            level = newlevel<br><br><span class="hljs-meta">        @attach_wrapper(<span class="hljs-params">wrapper</span>)</span><br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">set_message</span>(<span class="hljs-params">newmsg</span>):<br>            <span class="hljs-keyword">nonlocal</span> logmsg<br>            logmsg = newmsg<br><br>        <span class="hljs-keyword">return</span> wrapper<br>    <span class="hljs-keyword">return</span> decorate<br><br><span class="hljs-meta">@logged(<span class="hljs-params">logging.DEBUG</span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x,y</span>):<br>    <span class="hljs-keyword">return</span> x + y<br><br><span class="hljs-meta">@logged(<span class="hljs-params">logging.CRITICAL,<span class="hljs-string">&#x27;example&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">spam</span>():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Spam&#x27;</span>)<br><br><span class="hljs-comment"># 使用范例:可以再类外调用内内的属性设置了</span><br>add.set_message(<span class="hljs-string">&#x27;add called&#x27;</span>)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><br>add.set_level(logging.WARNING)<br>add(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><br></code></pre></td></tr></table></figure>
<h3 id="带可选参数的修饰器"><a href="#带可选参数的修饰器" class="headerlink" title="带可选参数的修饰器"></a>带可选参数的修饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 感觉没太理解这个文章中说到的不带参数的意思，难道可以不传入函数吗</span><br><span class="hljs-comment"># 先把模板放在这</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">logged</span>(<span class="hljs-params">func = <span class="hljs-literal">None</span>, *, level=logging.DEBUG,name=<span class="hljs-literal">None</span>, message=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> func <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">return</span> partial(logged,level=level,name=name,message=message)<br>    logname = name <span class="hljs-keyword">if</span> name <span class="hljs-keyword">else</span> func.__moudule__<br>    log = logging.getLogger(logname)<br>    logmsg = message <span class="hljs-keyword">if</span> message <span class="hljs-keyword">else</span> func.__name__<br><br><span class="hljs-meta">    @wraps(<span class="hljs-params">func</span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>(<span class="hljs-params">*args,**kwargs</span>):<br>        log.log(level,logmsg)<br>        <span class="hljs-keyword">return</span> func(*args,**kwargs)<br>    <span class="hljs-keyword">return</span> wrapper<br><br></code></pre></td></tr></table></figure>
<h3 id="property的用法"><a href="#property的用法" class="headerlink" title="@property的用法"></a>@property的用法</h3><p>将类别方法转换为类别属性，可以直接用.获取属性值或者对属性进行赋值。</p>
<p><strong>具体的实现和要求在后面再看看</strong></p>
<h1 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h1><p>@Aiken 2020</p>
<p>Python的异常处理操作：主要内容包括捕捉异常，抛出异常，基于异常进行判断处理等。<br>基本原理:</p>
<p>参考资料：  <a target="_blank" rel="noopener" href="https://www.runoob.com/python3/python3-errors-execptions.html">python3_错误和异常</a> 、 <a target="_blank" rel="noopener" href="https://www.runoob.com/python/python-exceptions.html">python3_错误和异常2</a></p>
<h2 id="Python3-错误和异常"><a href="#Python3-错误和异常" class="headerlink" title="Python3 错误和异常"></a>Python3 错误和异常</h2><p><strong>错误：</strong>一般语法解析器的解析错误，换句话说也就是基本的语法错误。<br><strong>异常：</strong>语法正确，但是运行期间出现的错误，</p>
<p>异常有很多种类：未定义，类型异常，除数0异常，etc.<br>…在附录附加常用常见的错误类型</p>
<h2 id="异常捕捉try-except"><a href="#异常捕捉try-except" class="headerlink" title="异常捕捉try except"></a>异常捕捉try except</h2><p>通过try exception 捕捉可能会出现的异常，然后用except，指定当该异常出现时候要执行的命令，可以指定多种异常。</p>
<p>基本的算法流程是：</p>
<ul>
<li>首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。</li>
<li>如果没有异常发生，忽略 except 子句，try 子句执行后结束。</li>
<li>如果在执行 try 子句的过程中发生了异常，那么 try 子句余下的部分将被忽略。如果异常的类型和 except 之后的名称相符，那么对应的 except 子句将被执行。</li>
</ul>
<p>如果一个异常没有与任何的 except 匹配，那么这个异常将会传递给上层的 try 中。<br>完整的算法逻辑如图所示👇，通常可以指使用t-e部分即可</p>
<p><img src="https://raw.githubusercontent.com/AikenH/md-image/master/img/try_except_else_finally.png" alt="https://raw.githubusercontent.com/AikenH/md-image/master/img/try_except_else_finally.png"></p>
<p>Image1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#主要依赖模块</span><br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> sys<br></code></pre></td></tr></table></figure>
<p><strong>写法的优点</strong></p>
<ul>
<li>在可预见的Exception出现的时候不会中断程序的进行， 可以以指定的方式进行规避，或者针对该情况进行特定的异常处理。</li>
</ul>
<p><strong>else的优势</strong></p>
<ul>
<li>如果try中出现了多个异常，我们可能会忽视其中的一些异常。</li>
<li>可以针对性的进行异常算法设计，这样会使得可读性和便于分析。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用try except的方式最好的一点在于，他不会终端程序的执行。</span><br><span class="hljs-keyword">try</span>:<br>    x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;please type in NUMBER &quot;</span>))<br><span class="hljs-keyword">except</span> ValueError:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;your input is not NUMBER&#x27;</span>)<br><br><span class="hljs-comment"># if we donot use t-e</span><br>x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;repeat you input&quot;</span>))<br><br><span class="hljs-comment"># 通过对比，我们可以知道这样执行的好处，在一些无关紧要的地方，</span><br><span class="hljs-comment"># 可以让程序继续运行而不必因为这些而中断。</span><br><br></code></pre></td></tr></table></figure>
<h3 id="exception的多种写法和多异常分支"><a href="#exception的多种写法和多异常分支" class="headerlink" title="exception的多种写法和多异常分支"></a>exception的多种写法和多异常分支</h3><p>try中的语句可能有<strong>多种异常抛出</strong>的情况：</p>
<ol>
<li>针对不同的异常进行处理。</li>
<li>统一处理不同异常。</li>
<li>统一处理所有类型</li>
</ol>
<p>以上面的代码为例：</p>
<ol>
<li>try except except …</li>
<li>EXCEPT (TUPLE)</li>
<li>except不带任何参数</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># type 1</span><br><span class="hljs-keyword">try</span>:<br>    x = <span class="hljs-number">123</span><br><span class="hljs-keyword">except</span> ValueError:<br>    t = <span class="hljs-number">123</span><br><span class="hljs-keyword">except</span> TypeError:<br>    y = <span class="hljs-number">123</span><br><br><span class="hljs-comment"># type 2</span><br><span class="hljs-keyword">try</span>:<br>    x = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;please type in NUMBER &quot;</span>))<br><span class="hljs-keyword">except</span> (ValueError,TypeError,NameError):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;your input is not NUMBER&#x27;</span>)<br><br></code></pre></td></tr></table></figure>
<p><strong>Try Import</strong> 使用try的结构来避免import过程中出现的问题：</p>
<p><a target="_blank" rel="noopener" href="https://www.programcreek.com/python/?CodeExample=try+import">Python try import (programcreek.com)</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">try_import</span>(<span class="hljs-params">package, message=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">__import__</span>(package)<br>    <span class="hljs-keyword">except</span> ImportError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> message:<br>            <span class="hljs-keyword">raise</span> e<br>        <span class="hljs-keyword">raise</span> ImportError(m)<br></code></pre></td></tr></table></figure>
<h2 id="抛出异常-Raise-Exception"><a href="#抛出异常-Raise-Exception" class="headerlink" title="抛出异常 Raise Exception"></a>抛出异常 Raise Exception</h2><p>使用raise 语句能够抛出指定类型的异常，从而终止程序的运行，和assert断言起到相似的作用。</p>
<p><strong>关键用法：</strong>设置异常抛出，然后用try except捕捉，然后进行指定的分支操作。<br><code>raise [Exception [, args [, traceback]]]</code></p>
<p><img src="https://raw.githubusercontent.com/AikenH/md-image/master/img/raise.png" alt="https://raw.githubusercontent.com/AikenH/md-image/master/img/raise.png"></p>
<p>raise_exception</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">x = <span class="hljs-number">10</span><br><span class="hljs-keyword">if</span> x &gt;= <span class="hljs-number">5</span>:<br>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;x 不能大于5，当前值为 &#123;&#125; &#x27;</span>.<span class="hljs-built_in">format</span>(x))<br><br></code></pre></td></tr></table></figure>
<h1 id="Numpy-Tips"><a href="#Numpy-Tips" class="headerlink" title="Numpy Tips"></a>Numpy Tips</h1><h2 id="reshape"><a href="#reshape" class="headerlink" title="reshape"></a>reshape</h2><p>和numpy格式的reshape的相关内容整合</p>
<ol>
<li>基本reshape的使用</li>
<li>reshape不改变原数据</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">bk1_a = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>])<br>bk1_b = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]])<br>bk1_c = bk1_a.reshape(bk1_b.shape)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;b&#x27;s datashpe is &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(bk1_b.shape))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;reshape by b。shape is ↓ \n &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(bk1_c))<br><span class="hljs-comment"># 测试是否改变原数据</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;b&#x27;s shape is &#123;&#125; &quot;</span>.<span class="hljs-built_in">format</span>(bk1_b.shape))<br><span class="hljs-keyword">assert</span> bk1_a ==  bk1_c, <span class="hljs-string">&#x27;do not change the origin data, a is like &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(bk1_a)<br><br></code></pre></td></tr></table></figure>
<h2 id="tolist"><a href="#tolist" class="headerlink" title="tolist"></a>tolist</h2><p>numpy array 和list之间的互相转换，在大规模编程中有比较广泛的应用场景。</p>
<ul>
<li>**有^次方的意思</li>
<li>arange 包含下限，不包含上线</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">bk2_a= (<span class="hljs-number">2</span> ** np.arange(<span class="hljs-number">4</span>,<span class="hljs-number">6</span>))<br><span class="hljs-comment"># bk2_a</span><br>bk2_b = bk2_a.tolist()<br><span class="hljs-comment"># bk2_b</span><br><br></code></pre></td></tr></table></figure>
<h2 id="用array给list中的元素赋值"><a href="#用array给list中的元素赋值" class="headerlink" title="用array给list中的元素赋值"></a>用array给list中的元素赋值</h2><p>以下是这种方式建立一个类似one-hot的函数介绍<br>可以很容易的从输出看出规律，而且最外层仍然是列表，也就是其中的元素是array</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">list1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">12</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(list1)):<br>    temp = list1[i]-<span class="hljs-number">1</span><br>    list1[i] = np.zeros(<span class="hljs-number">13</span>)<br>    list1[i][temp] = <span class="hljs-number">1</span><br>list1<br><br></code></pre></td></tr></table></figure>
<h2 id="flatten-amp-flat-operation"><a href="#flatten-amp-flat-operation" class="headerlink" title="flatten &amp; flat operation"></a>flatten &amp; flat operation</h2><p>flatten：将数据摊开降维成一维的数组/矩阵，以副本形式生成，不影响原数据<br>flat，生成一个迭代器，按行的形式迭代</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># A:flatten function B:flat function</span><br>bk3_a = np.random.rand(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;A is just like\n &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(bk3_a))<br>bk3_a2 = bk3_a.flatten()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;A2 is just like\n &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(bk3_a2))<br>printz(<span class="hljs-string">&#x27;********************clip*************************&#x27;</span>)<br>bk3_b = np.random.rand(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;B is just like \n&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(bk3_b))<br><span class="hljs-built_in">print</span>(bk3_b.flat, <span class="hljs-string">&#x27;as we can see, this is a iter&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> bk3_b.flat:<br>    <span class="hljs-built_in">print</span>(i)<br><br></code></pre></td></tr></table></figure>
<h2 id="Numpy-pad"><a href="#Numpy-pad" class="headerlink" title="Numpy.pad"></a>Numpy.pad</h2><p>pad，就是拓展原本数据的维度，方便后面机器学习中的其他步骤，主要用处包括：</p>
<ol>
<li>维度保持</li>
<li>增加对图像边界的重视</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## numpy.pad</span><br>x = np.random.randint(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>))<br>x = np.pad(x,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(x.shape)<br>h,w = x.shape[<span class="hljs-number">1</span>:]<br>new_h,new_w = <span class="hljs-number">3</span>,<span class="hljs-number">3</span><br><br>top = np.random.randint(<span class="hljs-number">0</span>,h-new_h)<br>left = np.random.randint(<span class="hljs-number">0</span>,w-new_w)<br><br>x = x[:,top: top+new_h,left:left+new_w]<br>x.shape<br><br></code></pre></td></tr></table></figure>
<h2 id="Numpy-索引中双冒号的实际用途"><a href="#Numpy-索引中双冒号的实际用途" class="headerlink" title=":: Numpy 索引中双冒号的实际用途"></a>:: Numpy 索引中双冒号的实际用途</h2><p>参照该文章进行分析，主要用途包括：对图像进行反转等操作<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/GracePro/article/details/102079331">https://blog.csdn.net/GracePro/article/details/102079331</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = np.random.rand(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;----------------------------&#x27;</span>)<br>a = a[:,::-<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(a)<br><br></code></pre></td></tr></table></figure>
<h2 id="Argpartition"><a href="#Argpartition" class="headerlink" title="Argpartition()"></a>Argpartition()</h2><p>借助于 argpartition()，Numpy 可以找出 N 个最大数值的索引，也会将找到的这些索引输出。<br>然后我们根据需要对数值进行排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.array([<span class="hljs-number">12</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">16</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>])<br>index_val = np.argpartition(x, -<span class="hljs-number">5</span>)[-<span class="hljs-number">5</span>:]<br>index2 = np.argmin(x)<br><span class="hljs-built_in">print</span>(index2)<br>index_val<br><br></code></pre></td></tr></table></figure>
<p>基于numpy的sort函数，输出找出的最大的几个数，要全体排序的话，还是考sort</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">np.sort(x[index_val])<br><br></code></pre></td></tr></table></figure>
<h2 id="Allclose"><a href="#Allclose" class="headerlink" title="Allclose()"></a>Allclose()</h2><p>allclose() 用于匹配两个数组，并得到布尔值表示的输出。如果在一个公差范围内（within a tolerance）两个数组不等同，<br><br>则 allclose() 返回 False。该函数对于检查两个数组是否相似非常有用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">array1 = np.array([<span class="hljs-number">0.12</span>,<span class="hljs-number">0.17</span>,<span class="hljs-number">0.24</span>,<span class="hljs-number">0.29</span>])<br>array2 = np.array([<span class="hljs-number">0.13</span>,<span class="hljs-number">0.19</span>,<span class="hljs-number">0.26</span>,<span class="hljs-number">0.31</span>])<br><span class="hljs-comment"># with a tolerance of 0.1, it should return False:</span><br><span class="hljs-built_in">print</span>(np.allclose(array1,array2,<span class="hljs-number">0.1</span>))<br><span class="hljs-comment"># with a tolerance of 0.2, it should return True:</span><br><span class="hljs-built_in">print</span>(np.allclose(array1,array2,<span class="hljs-number">0.2</span>))<br><br></code></pre></td></tr></table></figure>
<h2 id="Clip"><a href="#Clip" class="headerlink" title="Clip()"></a>Clip()</h2><p>使得一个数组中的数值保持在一个区间内。有时，我们需要保证数值在上下限范围内。为此，我们可以借助 Numpy 的 clip() <br>函数实现该目的。给定一个区间，则区间外的数值被剪切至区间上下限（interval edge）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.array([<span class="hljs-number">3</span>, <span class="hljs-number">17</span>, <span class="hljs-number">14</span>, <span class="hljs-number">23</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">16</span>, <span class="hljs-number">0</span>])<br>np.clip(x,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>)<br><br></code></pre></td></tr></table></figure>
<h2 id="extract"><a href="#extract" class="headerlink" title="extract()"></a>extract()</h2><p>顾名思义，extract() 是在特定条件下从一个数组中提取特定元素。<br>借助于 extract()，我们还可以使用 and 和 or 等条件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">array = np.random.randint(<span class="hljs-number">20</span>, size=<span class="hljs-number">12</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;basic array is &#123;&#125; &#x27;</span>.<span class="hljs-built_in">format</span>(array))<br><span class="hljs-comment">#  Divide by 2 and check if remainder is 1</span><br>cond = np.mod(array, <span class="hljs-number">2</span>)==<span class="hljs-number">1</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;是否符合条件的list，条件list\n  &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(cond))<br><span class="hljs-comment"># Use extract to get the values</span><br><span class="hljs-comment"># 提取出表现为True的哪些元素</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;按照条件提取出元素:\n &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(np.extract(cond, array)))<br><br><span class="hljs-comment"># Apply condition on extract directly</span><br><span class="hljs-comment"># 更直接的指定条件</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;复杂条件下的表现情况&#x27;</span>)<br><span class="hljs-built_in">print</span>(np.extract(((array &lt; <span class="hljs-number">3</span>) | (array &gt; <span class="hljs-number">15</span>)), array))<br><br></code></pre></td></tr></table></figure>
<h2 id="where"><a href="#where" class="headerlink" title="where()"></a>where()</h2><p>Where() 用于从一个数组中返回满足特定条件的元素。比如，它会返回满足特定条件的数值的索引位<br>Where() 与 SQL 中使用的 where condition 类似，如以下示例所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">y = np.array([<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">9</span>])<br><span class="hljs-comment"># Where y is greater than 5, returns index position</span><br><span class="hljs-built_in">print</span>(np.where(y&gt;<span class="hljs-number">5</span>))<br><span class="hljs-comment"># First will replace the values that match the condition,</span><br><span class="hljs-comment"># second will replace the values that does not</span><br><span class="hljs-built_in">print</span>(np.where(y&gt;<span class="hljs-number">5</span>, <span class="hljs-string">&quot;Hit&quot;</span>, <span class="hljs-string">&quot;Miss&quot;</span>))<br><br></code></pre></td></tr></table></figure>
<h1 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h1><p>记录一些典型错误，便于后续Debug的时候查找原因</p>
<h2 id="避免重复-冲突的import"><a href="#避免重复-冲突的import" class="headerlink" title="避免重复/冲突的import"></a>避免重复/冲突的import</h2><p>在工程实现中，对于同一个module。最好能做到<strong>不需要重复的import</strong>，但是在跨文件的工程项目中，或者说是一些跨文件调用的情况下，可能有一些基本的module会需要这样的时候，那我们最好做到<strong>不冲突</strong>，以同样的形式来进行import，不然有时候这样的重定义方式会出现一定的问题或者bug。<br>for example <code>from time import time</code> 和 <code>import time</code>同时出现的情况。</p>
<h2 id="内存调用与Method的定义"><a href="#内存调用与Method的定义" class="headerlink" title="内存调用与Method的定义"></a>内存调用与Method的定义</h2><p>在较为复杂的工程项目中，应该使用Method（Function）模块化的解决问题；这样做的优势可以从一下几点来看：</p>
<ol>
<li>易于阅读分析，写好相关method的Doc，然后做好注释，方便阅读和后续修改</li>
<li>能够在迭代过程中有效的释放暂态的变量，节约在主进程中无效的参数存储空间，节省内存或者显存。</li>
</ol>
<h2 id="TypeError："><a href="#TypeError：" class="headerlink" title="TypeError："></a>TypeError：</h2><p>一：<strong>cannnot unpack not-iterable NoneType object</strong>（无法解包非迭代类型的NoneType对象）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    <span class="hljs-keyword">if</span> value == <span class="hljs-number">1</span>:<br>        a=b=<span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> a, b<br>a,b = test()<br><span class="hljs-built_in">print</span>(a,b)<br><br></code></pre></td></tr></table></figure>
<p><strong>原因分析</strong>，当python函数没有确定的return的时候默认的返回值是None，这样在进行检查的时候，就会到导致编译的错误</p>
<p><strong>解决</strong>：指定默认的return，或者使用else方法完善所有情况下的return值的个数是一致的</p>
<p>二：<strong>missing 1 required positional argument： “self”</strong></p>
<p>对象的声明需要括号，我们可能在调用类内函数的时候，用错了变量，用了<strong>类而不是类的实例</strong>去调用这个函数，导致执行出现了错误。</p>
<p>三：<strong>builtin_function_or_method  error</strong></p>
<p>很多时候都是由于前面的数据操作少加了<code>()</code>导致的问题</p>
<p>四：<strong>bad operand type for unary -: ‘NoneType’</strong></p>
<p>输入的数据存在着值为空的情况，可能没定义之类的，问题要根据后面的具体报错来进行分析。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Python Notebook 01</p><p><a href="http://aikenh.cn/cn/Python/">http://aikenh.cn/cn/Python/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>AikenH</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2021-10-27</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2023-10-30</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/Python/">Python, </a><a class="link-muted" rel="tag" href="/tags/Langs/">Langs </a></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay.jpg" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechat.jpg" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/cn/fluent_python/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Fluent Python 01 数据模型与结构</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/cn/VSCode/"><span class="level-item">VsCode&#039;s Configuration</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'http://aikenh.cn/cn/Python/';
            this.page.identifier = 'cn/Python/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'my-tech-blog-3' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/title.jpg" alt="AikenH"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">AikenH</p><p class="is-size-6 is-block">Future Full-Stack Developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>ShenZhen</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">128</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">42</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">96</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/AikenH" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="ZhiHu" href="https://www.zhihu.com/people/Aiken-h"><i class="fab fa-zhihu"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/u/1788200627"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Steam" href="https://steamcommunity.com/id/AikenH/"><i class="fab fa-steam"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/AikenH"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#数据模型（Python结构的通用范式）"><span class="level-left"><span class="level-item">1</span><span class="level-item">数据模型（Python结构的通用范式）</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#基本命名规范"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">基本命名规范</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#变量赋值传递时的引用和拷贝"><span class="level-left"><span class="level-item">2</span><span class="level-item">变量赋值传递时的引用和拷贝</span></span></a></li><li><a class="level is-mobile" href="#类与函数"><span class="level-left"><span class="level-item">3</span><span class="level-item">类与函数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#匿名函数"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">匿名函数</span></span></a></li><li><a class="level is-mobile" href="#单下划线"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">单下划线</span></span></a></li><li><a class="level is-mobile" href="#Bool-and-or-not"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">Bool and or not</span></span></a></li><li><a class="level is-mobile" href="#Argparse"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">Argparse</span></span></a></li><li><a class="level is-mobile" href="#Random"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">Random</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Logging-System"><span class="level-left"><span class="level-item">4</span><span class="level-item">Logging System</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#基础使用"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">基础使用</span></span></a></li><li><a class="level is-mobile" href="#进阶使用"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">进阶使用</span></span></a></li><li><a class="level is-mobile" href="#Logger与装饰器的组合使用"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">Logger与装饰器的组合使用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#FIles-System"><span class="level-left"><span class="level-item">5</span><span class="level-item">FIles System</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Import-manage"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">Import manage</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#init-py-文件的作用"><span class="level-left"><span class="level-item">5.1.1</span><span class="level-item">init.py 文件的作用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Path-Manage"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">Path Manage</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#路径切分"><span class="level-left"><span class="level-item">5.2.1</span><span class="level-item">路径切分</span></span></a></li></ul></li><li><a class="level is-mobile" href="#文件遍历"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">文件遍历</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#os-walk"><span class="level-left"><span class="level-item">5.3.1</span><span class="level-item">os.walk()</span></span></a></li><li><a class="level is-mobile" href="#Glob-glob"><span class="level-left"><span class="level-item">5.3.2</span><span class="level-item">Glob.glob()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#文件读写"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">文件读写</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Data-Structural"><span class="level-left"><span class="level-item">6</span><span class="level-item">Data Structural</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#位运算"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">位运算</span></span></a></li><li><a class="level is-mobile" href="#二进制操作"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">二进制操作</span></span></a></li><li><a class="level is-mobile" href="#序列构成的数组"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">序列构成的数组</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#列表推导式的使用"><span class="level-left"><span class="level-item">6.3.1</span><span class="level-item">列表推导式的使用</span></span></a></li><li><a class="level is-mobile" href="#使用列表推导式生成笛卡尔积"><span class="level-left"><span class="level-item">6.3.2</span><span class="level-item">使用列表推导式生成笛卡尔积</span></span></a></li><li><a class="level is-mobile" href="#生成器表达式"><span class="level-left"><span class="level-item">6.3.3</span><span class="level-item">生成器表达式</span></span></a></li><li><a class="level is-mobile" href="#元组不仅是不可变的列表"><span class="level-left"><span class="level-item">6.3.4</span><span class="level-item">元组不仅是不可变的列表</span></span></a></li></ul></li><li><a class="level is-mobile" href="#列表的基本操作"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">列表的基本操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#列表的条件加和"><span class="level-left"><span class="level-item">6.4.1</span><span class="level-item">列表的条件加和</span></span></a></li><li><a class="level is-mobile" href="#列表的数乘"><span class="level-left"><span class="level-item">6.4.2</span><span class="level-item">列表的数乘</span></span></a></li><li><a class="level is-mobile" href="#range函数常用操作"><span class="level-left"><span class="level-item">6.4.3</span><span class="level-item">range函数常用操作</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Universal-Method"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">Universal Method</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Sort（）对列表进行排序"><span class="level-left"><span class="level-item">6.5.1</span><span class="level-item">Sort（）对列表进行排序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#队列queue-amp-deque"><span class="level-left"><span class="level-item">6.6</span><span class="level-item">队列queue &amp; deque</span></span></a></li><li><a class="level is-mobile" href="#SET集合"><span class="level-left"><span class="level-item">6.7</span><span class="level-item">SET集合</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#利用set进行去重"><span class="level-left"><span class="level-item">6.7.1</span><span class="level-item">利用set进行去重</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Dict，Hashmap"><span class="level-left"><span class="level-item">6.8</span><span class="level-item">Dict，Hashmap</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#判断字典中的key是否存在的方法"><span class="level-left"><span class="level-item">6.8.1</span><span class="level-item">判断字典中的key是否存在的方法</span></span></a></li><li><a class="level is-mobile" href="#字典中的常用方法"><span class="level-left"><span class="level-item">6.8.2</span><span class="level-item">字典中的常用方法</span></span></a></li><li><a class="level is-mobile" href="#collections-defaultdict-指定dict中未定义key的value"><span class="level-left"><span class="level-item">6.8.3</span><span class="level-item">collections.defaultdict 指定dict中未定义key的value</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Vars（）"><span class="level-left"><span class="level-item">6.9</span><span class="level-item">Vars（）</span></span></a></li><li><a class="level is-mobile" href="#Python中的数字日期时间计算"><span class="level-left"><span class="level-item">6.10</span><span class="level-item">Python中的数字日期时间计算</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#获取本机时间的几种方法"><span class="level-left"><span class="level-item">6.10.1</span><span class="level-item">获取本机时间的几种方法</span></span></a></li><li><a class="level is-mobile" href="#精确数字运算"><span class="level-left"><span class="level-item">6.10.2</span><span class="level-item">精确数字运算</span></span></a></li><li><a class="level is-mobile" href="#数字的格式化输出"><span class="level-left"><span class="level-item">6.10.3</span><span class="level-item">数字的格式化输出</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#迭代器"><span class="level-left"><span class="level-item">7</span><span class="level-item">迭代器</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#enumerate-、items、zip"><span class="level-left"><span class="level-item">7.1.1</span><span class="level-item">enumerate 、items、zip</span></span></a></li></ul></ul></li><li><a class="level is-mobile" href="#元编程"><span class="level-left"><span class="level-item">8</span><span class="level-item">元编程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Some-Rules"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">Some Rules</span></span></a></li><li><a class="level is-mobile" href="#装饰器模块"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">装饰器模块</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Basic-Type"><span class="level-left"><span class="level-item">8.2.1</span><span class="level-item">Basic Type</span></span></a></li><li><a class="level is-mobile" href="#接受参数传递"><span class="level-left"><span class="level-item">8.2.2</span><span class="level-item">接受参数传递</span></span></a></li><li><a class="level is-mobile" href="#修改装饰器参数"><span class="level-left"><span class="level-item">8.2.3</span><span class="level-item">修改装饰器参数</span></span></a></li><li><a class="level is-mobile" href="#带可选参数的修饰器"><span class="level-left"><span class="level-item">8.2.4</span><span class="level-item">带可选参数的修饰器</span></span></a></li><li><a class="level is-mobile" href="#property的用法"><span class="level-left"><span class="level-item">8.2.5</span><span class="level-item">@property的用法</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Exception"><span class="level-left"><span class="level-item">9</span><span class="level-item">Exception</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Python3-错误和异常"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">Python3 错误和异常</span></span></a></li><li><a class="level is-mobile" href="#异常捕捉try-except"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">异常捕捉try except</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#exception的多种写法和多异常分支"><span class="level-left"><span class="level-item">9.2.1</span><span class="level-item">exception的多种写法和多异常分支</span></span></a></li></ul></li><li><a class="level is-mobile" href="#抛出异常-Raise-Exception"><span class="level-left"><span class="level-item">9.3</span><span class="level-item">抛出异常 Raise Exception</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Numpy-Tips"><span class="level-left"><span class="level-item">10</span><span class="level-item">Numpy Tips</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#reshape"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">reshape</span></span></a></li><li><a class="level is-mobile" href="#tolist"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">tolist</span></span></a></li><li><a class="level is-mobile" href="#用array给list中的元素赋值"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">用array给list中的元素赋值</span></span></a></li><li><a class="level is-mobile" href="#flatten-amp-flat-operation"><span class="level-left"><span class="level-item">10.4</span><span class="level-item">flatten &amp; flat operation</span></span></a></li><li><a class="level is-mobile" href="#Numpy-pad"><span class="level-left"><span class="level-item">10.5</span><span class="level-item">Numpy.pad</span></span></a></li><li><a class="level is-mobile" href="#Numpy-索引中双冒号的实际用途"><span class="level-left"><span class="level-item">10.6</span><span class="level-item">:: Numpy 索引中双冒号的实际用途</span></span></a></li><li><a class="level is-mobile" href="#Argpartition"><span class="level-left"><span class="level-item">10.7</span><span class="level-item">Argpartition()</span></span></a></li><li><a class="level is-mobile" href="#Allclose"><span class="level-left"><span class="level-item">10.8</span><span class="level-item">Allclose()</span></span></a></li><li><a class="level is-mobile" href="#Clip"><span class="level-left"><span class="level-item">10.9</span><span class="level-item">Clip()</span></span></a></li><li><a class="level is-mobile" href="#extract"><span class="level-left"><span class="level-item">10.10</span><span class="level-item">extract()</span></span></a></li><li><a class="level is-mobile" href="#where"><span class="level-left"><span class="level-item">10.11</span><span class="level-item">where()</span></span></a></li></ul></li><li><a class="level is-mobile" href="#DEBUG"><span class="level-left"><span class="level-item">11</span><span class="level-item">DEBUG</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#避免重复-冲突的import"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">避免重复/冲突的import</span></span></a></li><li><a class="level is-mobile" href="#内存调用与Method的定义"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">内存调用与Method的定义</span></span></a></li><li><a class="level is-mobile" href="#TypeError："><span class="level-left"><span class="level-item">11.3</span><span class="level-item">TypeError：</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><figure class="media-left"><a class="image" href="/cn/Flashcard_template/"><img src="/img/header_img/lml_bg35.jpg" alt="Obsidian使用 Spaced Repetition 制作闪念卡片"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-10-27T16:39:59.000Z">2023-10-28</time></p><p class="title"><a href="/cn/Flashcard_template/">Obsidian使用 Spaced Repetition 制作闪念卡片</a></p><p class="categories"><a href="/categories/Editor/">Editor</a> / <a href="/categories/Editor/Obsidian/">Obsidian</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/cn/vsocde_regexp/"><img src="/img/header_img/lml_bg31.jpg" alt="VsCode&#039;s RegExp Catch 正则捕获"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-10-19T08:53:03.000Z">2023-10-19</time></p><p class="title"><a href="/cn/vsocde_regexp/">VsCode&#039;s RegExp Catch 正则捕获</a></p><p class="categories"><a href="/categories/Editor/">Editor</a> / <a href="/categories/Editor/Vscode/">Vscode</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/cn/GoMetis00_INTRO/"><img src="/img/header_img/lml_bg11.jpg" alt="GoMetis00_INTRO"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-10-08T09:58:57.000Z">2023-10-08</time></p><p class="title"><a href="/cn/GoMetis00_INTRO/">GoMetis00_INTRO</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/cn/TaskPhoto00_Xs20_Recipes/"><img src="/img/header_img/lml_bg4.jpg" alt="Photography00 XS20_Recipes"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-10-04T16:41:43.000Z">2023-10-05</time></p><p class="title"><a href="/cn/TaskPhoto00_Xs20_Recipes/">Photography00 XS20_Recipes</a></p><p class="categories"><a href="/categories/Photography/">Photography</a></p></div></article><article class="media"><figure class="media-left"><a class="image" href="/cn/HomeAssistant_Init/"><img src="/img/header_img/lml_bg40.jpg" alt="HomeAssistant01 入门基础篇"></a></figure><div class="media-content"><p class="date"><time dateTime="2023-08-12T09:24:50.000Z">2023-08-12</time></p><p class="title"><a href="/cn/HomeAssistant_Init/">HomeAssistant01 入门基础篇</a></p><p class="categories"><a href="/categories/NAS/">NAS</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Aiken&#039;s Blog</a><p class="is-size-7"><span>&copy; 2023 AikenH</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_pv">Visited by <span id="busuanzi_value_site_uv">0</span> users</span> and <span id="busuanzi_container2_site_uv"><span id="busuanzi_value_site_pv">0</span>&nbsp;visits</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><script src="/js/night.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>